diff -dur protra-protra_trunk-r551.org/trunk/Protra/Controls/ChartBox.cs protra-protra_trunk-r551/trunk/Protra/Controls/ChartBox.cs
--- protra-protra_trunk-r551.org/trunk/Protra/Controls/ChartBox.cs	2022-04-21 19:55:20.265314600 +0900
+++ protra-protra_trunk-r551/trunk/Protra/Controls/ChartBox.cs	2021-04-26 02:19:54.805716500 +0900
@@ -256,8 +256,8 @@
         {
             // グローバル変数の設定
             Interpreter.GlobalVariableTable.Clear();
-            Interpreter.GlobalVariableTable["$Names"] = new Value(new Value[6]);
-            Interpreter.GlobalVariableTable["$Colors"] = new Value(new Value[6]);
+            Interpreter.GlobalVariableTable["$Names"] = new Value(new Value[7]);
+            Interpreter.GlobalVariableTable["$Colors"] = new Value(new Value[7]);
             Interpreter.GlobalVariableTable["$IsTimeSeries"] = new Value(true);
 
             // 組み込み関数の設定
diff -dur protra-protra_trunk-r551.org/trunk/Protra/Dialogs/PriceUpdateDialog.cs protra-protra_trunk-r551/trunk/Protra/Dialogs/PriceUpdateDialog.cs
--- protra-protra_trunk-r551.org/trunk/Protra/Dialogs/PriceUpdateDialog.cs	2022-04-21 19:55:20.632985800 +0900
+++ protra-protra_trunk-r551/trunk/Protra/Dialogs/PriceUpdateDialog.cs	2021-04-26 19:37:20.793367000 +0900
@@ -22,6 +22,7 @@
 using System.ComponentModel;
 using System.Windows.Forms;
 using Protra.Lib;
+using Protra.Lib.Config;
 using Protra.Lib.Data;
 using Protra.Lib.Dialogs;
 using Protra.Lib.Update;
@@ -94,6 +95,7 @@
 
         private void backgroundWorkerUpdate_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
+            var config = GlobalEnv.ProtraConfig;
             if (e.Error != null)
             {
                 using (new CenteredDialogHelper())
@@ -107,6 +109,11 @@
             else
             {
                 labelInfo.Text = "更新が完了しました。";
+                if (config.Autoclose)
+                {
+                     this.Close();
+                     Application.Exit();
+                }
             }
             Cursor = Cursors.Arrow;
             buttonCancel.Enabled = true;
diff -dur protra-protra_trunk-r551.org/trunk/Protra/MainForm.cs protra-protra_trunk-r551/trunk/Protra/MainForm.cs
--- protra-protra_trunk-r551.org/trunk/Protra/MainForm.cs	2022-04-21 19:55:20.075438700 +0900
+++ protra-protra_trunk-r551/trunk/Protra/MainForm.cs	2021-04-26 19:43:20.742177200 +0900
@@ -214,7 +214,7 @@
         private void SetBrandInfo(Brand brand)
         {
             labelCode.Text = brand.Code + " " + brand.MarketName;
-            labelBrandName.Text = brand.Name;
+            labelBrandName.Text = brand.Name.Replace("&", "&&");
         }
 
         /// <summary>
@@ -251,7 +251,7 @@
             var contextMenu = new ContextMenu();
             foreach (var brand in brands)
             {
-                var menuItem = new MenuItem {Text = brand.ToString(), Tag = brand};
+                var menuItem = new MenuItem {Text = brand.ToString().Replace("&", "&&"), Tag = brand};
                 menuItem.Click += menuItemSearchedBrand_Click;
                 contextMenu.MenuItems.Add(menuItem);
             }
@@ -391,7 +391,6 @@
             bl.List.Add(code);
             GlobalEnv.BrandListConfig.Save();
         }
-
         private void listDelToolStripMenuItem_Click(object sender, EventArgs e)
         {
             var brandListIndex = comboBoxBrandList.SelectedIndex;
@@ -409,5 +408,12 @@
             listBoxBrandList.SelectedIndex = brandIndex == listBoxBrandList.Items.Count ? brandIndex - 1 : brandIndex;
             GlobalEnv.BrandListConfig.Save();
         }
+
+        private void MainForm_Shown(object sender, EventArgs e)
+        {
+            var config = GlobalEnv.ProtraConfig;
+            if (config.Autoclose)
+                 priceUpdateToolStripMenuItem.PerformClick();
+        }
     }
 }
\ No newline at end of file
diff -dur protra-protra_trunk-r551.org/trunk/Protra/MainForm.designer.cs protra-protra_trunk-r551/trunk/Protra/MainForm.designer.cs
--- protra-protra_trunk-r551.org/trunk/Protra/MainForm.designer.cs	2022-04-21 19:55:19.668964300 +0900
+++ protra-protra_trunk-r551/trunk/Protra/MainForm.designer.cs	2021-04-26 19:44:55.689645700 +0900
@@ -605,6 +605,7 @@
             this.Text = "Protra";
             this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.MainForm_FormClosing);
             this.Load += new System.EventHandler(this.MainForm_Load);
+            this.Shown += new System.EventHandler(this.MainForm_Shown);
             this.mainMenuStrip.ResumeLayout(false);
             this.mainMenuStrip.PerformLayout();
             this.mainToolStrip.ResumeLayout(false);
Only in protra-protra_trunk-r551/trunk/Protra: obj
Only in protra-protra_trunk-r551/trunk/Protra: Protra.xml
diff -dur protra-protra_trunk-r551.org/trunk/Protra.Lib/Config/ProtraConfig.cs protra-protra_trunk-r551/trunk/Protra.Lib/Config/ProtraConfig.cs
--- protra-protra_trunk-r551.org/trunk/Protra.Lib/Config/ProtraConfig.cs	2022-04-21 19:55:23.811733400 +0900
+++ protra-protra_trunk-r551/trunk/Protra.Lib/Config/ProtraConfig.cs	2021-04-26 19:14:15.948793000 +0900
@@ -142,6 +142,11 @@
         }
 
         /// <summary>
+        /// アプリを強制終了するかを取得または設定する。
+        /// </summary>
+        public bool Autoclose { get; set; }
+
+        /// <summary>
         /// コンストラクタ。
         /// </summary>
         public ProtraConfig()
diff -dur protra-protra_trunk-r551.org/trunk/Protra.Lib/Config/PtSimConfig.cs protra-protra_trunk-r551/trunk/Protra.Lib/Config/PtSimConfig.cs
--- protra-protra_trunk-r551.org/trunk/Protra.Lib/Config/PtSimConfig.cs	2022-04-21 19:55:23.883582800 +0900
+++ protra-protra_trunk-r551/trunk/Protra.Lib/Config/PtSimConfig.cs	2021-04-26 18:50:03.229797300 +0900
@@ -68,6 +68,11 @@
         public string SystemFile { get; set; }
 
         /// <summary>
+        /// アプリを強制終了するかを取得または設定する。
+        /// </summary>
+        public bool Autoclose { get; set; }
+
+        /// <summary>
         /// 設定ファイルの名前を取得する。
         /// </summary>
         protected override string ConfigName
diff -dur protra-protra_trunk-r551.org/trunk/Protra.Lib/Lang/Builtins/DrawBuiltins.cs protra-protra_trunk-r551/trunk/Protra.Lib/Lang/Builtins/DrawBuiltins.cs
--- protra-protra_trunk-r551.org/trunk/Protra.Lib/Lang/Builtins/DrawBuiltins.cs	2022-04-21 19:55:23.580143300 +0900
+++ protra-protra_trunk-r551/trunk/Protra.Lib/Lang/Builtins/DrawBuiltins.cs	2021-04-26 02:24:00.538840600 +0900
@@ -156,8 +156,8 @@
             _functionList = new List<DrawFunctionRecord>();
             MinY = double.MaxValue;
             MaxY = double.MinValue;
-            Indicators = new Dictionary<int, double>[6];
-            for (var i = 0; i < 6; i++)
+            Indicators = new Dictionary<int, double>[7];
+            for (var i = 0; i < 7; i++)
                 Indicators[i] = new Dictionary<int, double>();
         }
 
diff -dur protra-protra_trunk-r551.org/trunk/Protra.Lib/Lang/Builtins/SimulateBuiltins.cs protra-protra_trunk-r551/trunk/Protra.Lib/Lang/Builtins/SimulateBuiltins.cs
--- protra-protra_trunk-r551.org/trunk/Protra.Lib/Lang/Builtins/SimulateBuiltins.cs	2022-04-21 19:55:23.664573100 +0900
+++ protra-protra_trunk-r551/trunk/Protra.Lib/Lang/Builtins/SimulateBuiltins.cs	2021-04-26 02:26:28.070261300 +0900
@@ -128,14 +128,16 @@
             {
                 case "Buy":
                     log.Order = Order.Buy;
-                    if (!LogData.Add(log))
-                        throw new RuntimeException("同日の売買があります。", null);
+//                    if (!LogData.Add(log))
+//                        throw new RuntimeException("同日の売買があります。", null);
+                    LogData.Add(log);
                     msg += "買\r\n";
                     break;
                 case "Sell":
                     log.Order = Order.Sell;
-                    if (!LogData.Add(log))
-                        throw new RuntimeException("同日の売買があります。", null);
+//                    if (!LogData.Add(log))
+//                        throw new RuntimeException("同日の売買があります。", null);
+                    LogData.Add(log);
                     msg += "売\r\n";
                     break;
                 default:
Only in protra-protra_trunk-r551/trunk/Protra.Lib: obj
Only in protra-protra_trunk-r551/trunk/Protra.Lib: Protra.Lib.xml
diff -dur protra-protra_trunk-r551.org/trunk/PtSim/Controls/ProfitGraphBox.cs protra-protra_trunk-r551/trunk/PtSim/Controls/ProfitGraphBox.cs
--- protra-protra_trunk-r551.org/trunk/PtSim/Controls/ProfitGraphBox.cs	2022-04-21 19:55:12.703182300 +0900
+++ protra-protra_trunk-r551/trunk/PtSim/Controls/ProfitGraphBox.cs	2021-05-22 12:14:48.000000000 +0900
@@ -129,30 +129,109 @@
 
         private void DrawHorizontalScale()
         {
-            var years = 0;
-            var prevYear = -1;
-            foreach (var date in ProfitList.Dates)
+            int years = 0;
+
+            int startIndex = 0;
+            int endIndex = ProfitList.Count - 1;
+
+            // 最初の取引を探す
+            for (int i = 0; i < ProfitList.Count; i++)
             {
-                if (date.Year == prevYear)
-                    continue;
-                years++;
-                prevYear = date.Year;
+                if (ProfitList[i].Market != 0.0)
+                {
+                    if ((ProfitList.Dates[i].Year == ProfitList.Dates[startIndex].Year) && (ProfitList.Dates[i].Month == ProfitList.Dates[startIndex].Month))
+                    {
+                        // 最初の取引が全データの最初の年月なので開始インデックスは全データの先頭のままとする
+                        break;
+                    }
+
+                    // 表示上の見易さの為に最初の取引の当年の開始日を開始インデックスにする
+                    for (int j = 0; j < ProfitList.Dates.Count; j++)
+                    {
+                        // 1月の場合は前年の12月
+                        if (ProfitList.Dates[i].Month == 1)
+                        {
+                            if ((ProfitList.Dates[j].Year == (ProfitList.Dates[i].Year - 1)) && (ProfitList.Dates[j].Month == 12))
+                            {
+                                startIndex = j;
+                                break;
+                            }
+                        }
+                        else
+                        {
+                            if (ProfitList.Dates[j].Year == ProfitList.Dates[i].Year)
+                            {
+                                startIndex = j;
+                                break;
+                            }
+                        }
+                    }
+
+                    break;
+                }
+            }
+
+            // 最後の取引を探す
+            for (int i = endIndex; i > 0; i--)
+            {
+                if (ProfitList[i].Book != ProfitList[(i - 1)].Book)
+                {
+                    if ((ProfitList.Dates[i].Year == ProfitList.Dates[endIndex].Year) && (ProfitList.Dates[i].Month == ProfitList.Dates[endIndex].Month))
+                    {
+                        // 最後の取引が全データの最後の年月なので終了インデックスは全データの末端のままとする
+                        break;
+                    }
+
+                    // 表示上の見易さの為に最後の取引の翌月の終了日を終了インデックスにする
+                    for (int j = endIndex; i > 0; j--)
+                    {
+                        // 12月の場合は翌年の1月
+                        if (ProfitList.Dates[i].Month == 12)
+                        {
+                            if ((ProfitList.Dates[j].Year == (ProfitList.Dates[i].Year + 1)) && (ProfitList.Dates[j].Month == 1))
+                            {
+                                endIndex = j;
+                                break;
+                            }
+                        }
+                        else
+                        {
+                            if ((ProfitList.Dates[j].Year == ProfitList.Dates[i].Year) && (ProfitList.Dates[j].Month == (ProfitList.Dates[i].Month + 1)))
+                            {
+                                endIndex = j;
+                                break;
+                            }
+                        }
+                    }
+
+                    break;
+                }
             }
+
+            //_xscale = (_chartRectangle.Width - 2) / (ProfitList.Dates.Count - startIndex);
+            _xscale = (_chartRectangle.Width - 2) / (endIndex - startIndex);
+
+            years = ProfitList.Dates[ProfitList.Dates.Count - 1].Year - ProfitList.Dates[startIndex].Year + 1;
+
             var tickRange = 1;
             var labelWidth = _graphics.MeasureString("99", Font).Width;
             while (_chartRectangle.Width * tickRange / years < labelWidth * 1.1)
                 tickRange++;
             var smallTickRange = tickRange == 1 ? 3 : 6;
             var prevMonth = -1;
-            var startYear = ProfitList.Dates[0].Year;
+
+            int startYear = ProfitList.Dates[startIndex].Year;
+
             const int tickHeight = 3;
-            for (var i = 0; i < ProfitList.Dates.Count; i++)
+
+            //for (int i = startIndex; i < ProfitList.Dates.Count; i++)
+            for (int i = startIndex; i <= endIndex; i++)
             {
                 var date = ProfitList.Dates[i];
                 if (date.Month == prevMonth)
                     continue;
                 prevMonth = date.Month;
-                var x = _xscale * i;
+                float x = _xscale * (i - startIndex);
                 var bottom = _chartRectangle.Bottom;
                 if (date.Month == 1)
                 {
@@ -168,17 +247,100 @@
 
         private void DrawProfitLines()
         {
+            int startIndex = 0;
+            int endIndex = ProfitList.Count - 1;
+
+            // 最初の取引を探す
+            for (int i = 0; i < ProfitList.Count; i++)
+            {
+                if (ProfitList[i].Market != 0.0)
+                {
+                    if ((ProfitList.Dates[i].Year == ProfitList.Dates[startIndex].Year) && (ProfitList.Dates[i].Month == ProfitList.Dates[startIndex].Month))
+                    {
+                        // 最初の取引が全データの最初の年月なので開始インデックスは全データの先頭のままとする
+                        break;
+                    }
+
+                    // 表示上の見易さの為に最初の取引の当年の開始日を開始インデックスにする
+                    for (int j = 0; j < ProfitList.Dates.Count; j++)
+                    {
+                        // 1月の場合は前年の12月
+                        if (ProfitList.Dates[i].Month == 1)
+                        {
+                            if ((ProfitList.Dates[j].Year == (ProfitList.Dates[i].Year - 1)) && (ProfitList.Dates[j].Month == 12))
+                            {
+                                startIndex = j;
+                                break;
+                            }
+                        }
+                        else
+                        {
+                            if (ProfitList.Dates[j].Year == ProfitList.Dates[i].Year)
+                            {
+                                startIndex = j;
+                                break;
+                            }
+                        }
+                    }
+
+                    break;
+                }
+            }
+
+            // 最後の取引を探す
+            for (int i = endIndex; i > 0; i--)
+            {
+                if (ProfitList[i].Book != ProfitList[(i - 1)].Book)
+                {
+                    if ((ProfitList.Dates[i].Year == ProfitList.Dates[endIndex].Year) && (ProfitList.Dates[i].Month == ProfitList.Dates[endIndex].Month))
+                    {
+                        // 最後の取引が全データの最後の年月なので終了インデックスは全データの末端のままとする
+                        break;
+                    }
+
+                    // 表示上の見易さの為に最後の取引の翌月の終了日を終了インデックスにする
+                    for (int j = endIndex; i > 0; j--)
+                    {
+                        // 12月の場合は翌年の1月
+                        if (ProfitList.Dates[i].Month == 12)
+                        {
+                            if ((ProfitList.Dates[j].Year == (ProfitList.Dates[i].Year + 1)) && (ProfitList.Dates[j].Month == 1))
+                            {
+                                endIndex = j;
+                                break;
+                            }
+                        }
+                        else
+                        {
+                            if ((ProfitList.Dates[j].Year == ProfitList.Dates[i].Year) && (ProfitList.Dates[j].Month == (ProfitList.Dates[i].Month + 1)))
+                            {
+                                endIndex = j;
+                                break;
+                            }
+                        }
+                    }
+
+                    break;
+                }
+            }
+
+            //_xscale = (_chartRectangle.Width - 2) / (ProfitList.Dates.Count - startIndex);
+            _xscale = (_chartRectangle.Width - 2) / (endIndex - startIndex);
+
             var yscale = _chartRectangle.Height / (_upperBound - _lowerBound);
             var marketPrevPoint = new PointF();
             var bookPrevPoint = new PointF();
-            for (var i = 0; i < ProfitList.Count; i++)
+
+            //for (int i = startIndex; i < ProfitList.Count; i++)
+            for (int i = startIndex; i <= endIndex; i++)
             {
                 var profit = ProfitList[i];
                 var top = _chartRectangle.Top;
-                var x = _xscale * i;
+                float x = _xscale * (i - startIndex);
                 var marketPoint = new PointF(x, yscale * (_upperBound - profit.Market) + top);
                 var bookPoint = new PointF(x, yscale * (_upperBound - profit.Book) + top);
-                if (i > 0)
+                //if (i > 0)
+                if (i > startIndex)
                 {
                     _graphics.DrawLine(new Pen(_marketColor), marketPrevPoint, marketPoint);
                     _graphics.DrawLine(new Pen(_bookColor), bookPrevPoint, bookPoint);
diff -dur protra-protra_trunk-r551.org/trunk/PtSim/MainForm.cs protra-protra_trunk-r551/trunk/PtSim/MainForm.cs
--- protra-protra_trunk-r551.org/trunk/PtSim/MainForm.cs	2022-04-21 19:55:11.943044900 +0900
+++ protra-protra_trunk-r551/trunk/PtSim/MainForm.cs	2021-05-26 19:58:49.785834800 +0900
@@ -25,6 +25,8 @@
 using System.Drawing;
 using System.Globalization;
 using System.Windows.Forms;
+using System.IO;
+using System.Text;
 using Protra.Lib;
 using Protra.Lib.Config;
 using Protra.Lib.Data;
@@ -39,6 +41,9 @@
     /// </summary>
     public partial class MainForm : Form
     {
+        private string _name;
+        private DateTime _startTime;
+
         /// <summary>
         /// アプリケーションのメインエントリポイント
         /// </summary>
@@ -74,6 +79,7 @@
             dateTimePickerHistoryFrom.Value = DateTime.Now.AddMonths(-1); //履歴の開始を1ヶ月前に設定する。
             ptFileTreeView.RootDirectory = Global.DirSystem; // システム一覧を更新する。
             ptFileTreeView.SelectedFile = config.SystemFile;
+            _startTime = DateTime.MaxValue;
         }
 
         private void BrandListInit()
@@ -237,6 +243,7 @@
             var brandList = comboBoxBrandList.SelectedItem;
             if (system == null || brandList == null)
                 return;
+            _startTime = DateTime.Now;
             buttonExecute.Text = "中断";
             SetEnabled(EnableFlags.Execute);
             textBoxExecute.Clear();
@@ -247,6 +254,7 @@
         {
             var worker = (BackgroundWorker)sender;
             var args = (Object[])e.Argument;
+            _name = (string)args[0];
             var executor = new SystemExecutor((string)args[0], (BrandList)args[1], (TimeFrame)args[2]);
             executor.Execute(worker, WrapInvoke(textBoxExecute.AppendText));
             if (worker.CancellationPending)
@@ -272,6 +280,7 @@
 
         private void backgroundWorkerExecute_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
+            var config = GlobalEnv.PtSimConfig;
             if (e.Error != null)
                 textBoxExecute.AppendText(e.Error.Message + "\r\nエラーが発生したので実行を中断します。");
             else if (e.Cancelled)
@@ -283,6 +292,24 @@
                 EndInvoke(_asyncResult); // 最後のBeginInvokeの後始末をする。
                 _asyncResult = null;
             }
+            {
+                // ファイルに書き出しをする
+                DateTime _endTime = DateTime.Now;
+                TimeSpan ts = _endTime - _startTime;
+                File.WriteAllText(@".\data\log\lasttrading.txt",
+                         "実行時間 = " + (int)ts.Days + "日" +
+                                         (int)ts.Hours + "時間" +
+                                         (int)ts.Minutes + "分" +
+                                         (int)ts.Seconds + "秒\r\n" +
+                         textBoxExecute.Text);
+                String filePath = @".\data\log\trading_" + _name + "_" + _endTime.ToString("yyyyMMddHHmmss") + ".txt";
+                File.WriteAllText(filePath, 
+                         "実行時間 = " + (int)ts.Days + "日" +
+                                         (int)ts.Hours + "時間" +
+                                         (int)ts.Minutes + "分" +
+                                         (int)ts.Seconds + "秒\r\n" +
+                         textBoxExecute.Text);
+            }
             Cursor = Cursors.Arrow;
             buttonExecute.Text = "実行";
             progressBarExecute.Value = 0;
@@ -290,6 +317,10 @@
                 SetEnabled(EnableFlags.All);
             else
                 SetEnabled(EnableFlags.DeleteLogAll | EnableFlags.EditBrandList);
+            if (config.Autoclose)
+            {
+               Application.Exit();
+            }
         }
 
         private void buttonPerformance_Click(object sender, EventArgs e)
@@ -314,6 +345,7 @@
         {
             var worker = (BackgroundWorker)sender;
             var args = (Object[])e.Argument;
+            _name = (string)args[0];
             var performance = new Performance((string)args[0], (BrandList)args[1], (TimeFrame)args[2]);
             var profits = performance.Calculate(worker, WrapInvoke(richTextBoxPerformance.AppendText));
             if (worker.CancellationPending)
@@ -396,5 +428,33 @@
                 return;
             Clipboard.SetDataObject(string.Concat(rows));
         }
+
+        private void MainForm_Shown(object sender, EventArgs e)
+        {
+            var config = GlobalEnv.PtSimConfig;
+            if (config.Autoclose)
+            {
+                if (backgroundWorkerExecute.IsBusy)
+                {
+                    backgroundWorkerExecute.CancelAsync();
+                    Cursor = Cursors.WaitCursor;
+                    buttonExecute.Enabled = false;
+                    return;
+                }
+                var system = ptFileTreeView.SelectedFile;
+                var brandList = comboBoxBrandList.SelectedItem;
+                if (system == null || brandList == null)
+                    return;
+                buttonExecute.Text = "中断";
+                SetEnabled(EnableFlags.Execute);
+                textBoxExecute.Clear();
+                backgroundWorkerExecute.RunWorkerAsync(new[] { system, brandList, TimeFrame });
+            }
+        }
+
+        private void ExitToolStripMenuItem_Click(object sender, EventArgs e)
+        {
+
+        }
     }
 }
\ No newline at end of file
diff -dur protra-protra_trunk-r551.org/trunk/PtSim/MainForm.Designer.cs protra-protra_trunk-r551/trunk/PtSim/MainForm.Designer.cs
--- protra-protra_trunk-r551.org/trunk/PtSim/MainForm.Designer.cs	2022-04-21 19:55:11.900845100 +0900
+++ protra-protra_trunk-r551/trunk/PtSim/MainForm.Designer.cs	2021-04-27 11:22:00.712502800 +0900
@@ -168,6 +168,7 @@
             this.ExitToolStripMenuItem.Name = "ExitToolStripMenuItem";
             this.ExitToolStripMenuItem.Size = new System.Drawing.Size(254, 22);
             this.ExitToolStripMenuItem.Text = "終了(&X)";
+            this.ExitToolStripMenuItem.Click += new System.EventHandler(this.ExitToolStripMenuItem_Click);
             // 
             // brandListToolStripMenuItem
             // 
@@ -624,6 +625,7 @@
             this.Text = "PtSim";
             this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.MainForm_FormClosing);
             this.Load += new System.EventHandler(this.MainForm_Load);
+            this.Shown += new System.EventHandler(this.MainForm_Shown);
             this.menuStripMain.ResumeLayout(false);
             this.menuStripMain.PerformLayout();
             this.contextMenuStripHistory.ResumeLayout(false);
Only in protra-protra_trunk-r551/trunk/PtSim: obj
diff -dur protra-protra_trunk-r551.org/trunk/PtSim/Performance.cs protra-protra_trunk-r551/trunk/PtSim/Performance.cs
--- protra-protra_trunk-r551.org/trunk/PtSim/Performance.cs	2022-04-21 19:55:11.849130000 +0900
+++ protra-protra_trunk-r551/trunk/PtSim/Performance.cs	2021-05-22 12:46:44.593979000 +0900
@@ -20,6 +20,7 @@
 
 using System;
 using System.ComponentModel;
+using System.Collections.Generic;
 using Protra.Lib.Config;
 using Protra.Lib.Data;
 using Protra.Lib.Lang.Builtins;
@@ -37,6 +38,9 @@
 
         private int _allTrades; // 全トレード数
         private int _winTrades; // 勝ちトレード数
+        private int _maxwinCount; // 連勝回数
+        private int _maxloseCount; // 連敗回数
+        private int _consecutiveWin; // 連勝・連敗中フラグ
         private float _allProfitRatio; // 全トレード平均損益率
         private float _winProfitRatio; // 勝ちトレード平均利率
         private float _winMaxProfitRatio; // 勝ちトレード最大利率
@@ -47,6 +51,22 @@
         private float _bookMaxPosition; // 時価の最大ポジション
         private float _marketMaxPosition; // 簿価の最大ポジション
         private float _totalProfit; // 総利益
+        private Dictionary<int, float> _allTradesYear;   // 各年のトレード数
+        private Dictionary<int, float> _totalProfitYear; // 各年の総利益
+        private Dictionary<int, float> _totalWinTradesYear; // 各年の勝率
+        private Dictionary<int, float> _allTradesMonth;   // 各月のトレード数
+        private Dictionary<int, float> _totalProfitMonth; // 各月の総利益
+        private Dictionary<int, float> _totalWinTradesMonth; // 各月の勝率
+        private Dictionary<int, float> _totalMaxDrowDownYear; // 各年の最大ドローダウン
+        private Dictionary<int, float> _totalMaxBookDrowDownYear; // 各年の簿価最大ドローダウン
+        private Dictionary<int, float> _totalMaxMarketDrowDownYear; // 各年の時価最大ドローダウン
+        private Dictionary<int, float> _totalWinMaxProfitYear; // 各年の勝ちトレード最大利益
+        private Dictionary<int, float> _totalLoseMaxProfitYear; // 各年の負けトレード最大損失
+        private Dictionary<int, DateTime> _maxBookDrowDawnDate; // Max簿価DDのトレードの日付
+        private Dictionary<int, DateTime> _maxMarketDrowDawnDate; // Max時価DDのトレードの日付
+        private Dictionary<int, float> _totalMaxDrowDownMonth; // 各月の最大ドローダウン
+        private Dictionary<int, float> _totalWinMaxProfitMonth; // 各月の勝ちトレード最大利益
+        private Dictionary<int, float> _totalLoseMaxProfitMonth; // 各月の負けトレード最大損失
         private float _winTotalProfit; // 勝ちトレード総利益
         private float _winMaxProfit; // 勝ちトレード最大利益
         private float _loseMaxLoss; // 負けトレード最大損失
@@ -67,6 +87,23 @@
             _name = name;
             _brandList = brandList;
             _timeFrame = timeFrame;
+            _consecutiveWin = 0;
+            _allTradesYear = new Dictionary<int, float>();
+            _totalProfitYear = new Dictionary<int, float>();
+            _totalWinTradesYear = new Dictionary<int, float>();
+            _allTradesMonth = new Dictionary<int, float>();
+            _totalProfitMonth = new Dictionary<int, float>();
+            _totalWinTradesMonth = new Dictionary<int, float>();             
+            _totalMaxDrowDownYear = new Dictionary<int, float>(); 
+            _totalMaxBookDrowDownYear = new Dictionary<int, float>(); 
+            _totalMaxMarketDrowDownYear = new Dictionary<int, float>(); 
+            _totalWinMaxProfitYear = new Dictionary<int, float>(); 
+            _totalLoseMaxProfitYear = new Dictionary<int, float>();
+            _maxBookDrowDawnDate = new Dictionary<int, DateTime>();
+            _maxMarketDrowDawnDate = new Dictionary<int, DateTime>();
+            _totalMaxDrowDownMonth = new Dictionary<int, float>(); 
+            _totalWinMaxProfitMonth = new Dictionary<int, float>(); 
+            _totalLoseMaxProfitMonth = new Dictionary<int, float>();
         }
 
         /// <summary>
@@ -84,10 +121,36 @@
                 return null;
             _firstTrade = profits.Dates[0];
             _lastTrade = profits.Dates[profits.Count - 1];
+
+            // 実取引が最初にあった日を探す
+            for (int i = 0; i < profits.Count; i++)
+            {
+                if (profits[i].Market != 0.0)
+                {
+                    _firstTrade = profits.Dates[i];
+                    break;
+                }
+            }
+
+            // 実取引が最後にあった日を探す
+            for (int i = (profits.Count - 1); i > 0; i--)
+            {
+                if (profits[i].Book != profits[(i - 1)].Book)
+                {
+                    _lastTrade = profits.Dates[i];
+                    break;
+                }
+            }
+
             PrintResult(appendText);
             return profits;
         }
 
+        private int T(int a, int b)
+        {
+            return a * 100 + b;
+        }
+                    
         private PricePairList AnalyzeLogs(BackgroundWorker worker)
         {
             var profits = new PricePairList();
@@ -120,6 +183,8 @@
                         var dailyProfit = profits[price.Date];
                         var dailyValue = positionValues[price.Date];
                         var close = price.Close;
+//                        if (position != 0 && close > 0 && prevClose > 0)
+//                            dailyProfit.AddMarket(position, close - prevClose); // 時価の前日比を加算する。
                         if (position != 0 && close > 0 && prevClose > 0)
                             dailyProfit.AddMarket(position, close - prevClose); // 時価の前日比を加算する。
                         if (close > 0)
@@ -127,6 +192,7 @@
                         if (price.High > 0)
                             prevHigh = price.High;
                         dailyValue.AddMarket(Math.Abs(position), prevHigh);
+//                        dailyValue.AddMarket(Math.Abs(position), prevHigh);
                         Log log;
                         if (logIndex == logs.Count || logs[logIndex].Date != price.Date || // 売買が発生しない。
                             (log = logs[logIndex++]).Quantity == 0) // 0株の売買は無視する。
@@ -139,11 +205,15 @@
                             totalBuy += consideration;
                             if (close > 0)
                                 dailyProfit.AddMarket(log.Quantity, close - log.Price);
+//                            if (close > 0)
+//                                dailyProfit.AddMarket(log.Quantity, close - log.Price);
                         }
                         else
                         {
                             position -= log.Quantity;
                             totalSell += consideration;
+//                            if (close > 0)
+//                                dailyProfit.AddMarket(log.Quantity, log.Price - close);
                             if (close > 0)
                                 dailyProfit.AddMarket(log.Quantity, log.Price - close);
                         }
@@ -183,7 +253,7 @@
                             realTotalBuy -= (totalBuy = (float)position * log.Price);
                         else if (position < 0)
                             realTotalSell -= (totalSell = (float)-position * log.Price);
-                        EvaluateTrade(log.Order == Order.Sell, (log.Date - startDate).Days, realTotalBuy, realTotalSell);
+                        EvaluateTrade(log.Order == Order.Sell, (log.Date - startDate).Days, realTotalBuy, realTotalSell, log.Date, dailyProfit);
                     }
                     if (position != 0)
                         _runningTrades++;
@@ -198,17 +268,112 @@
             return realProfits;
         }
 
-        private void EvaluateTrade(bool isLong, int term, float totalBuy, float totalSell)
+        private void EvaluateTrade(bool isLong, int term, float totalBuy, float totalSell, DateTime date, PricePair dailyprofit)
         {
+            var year = date.Year;
+            var month = date.Month;
             _allTrades++;
             var ratio = isLong ? totalSell / totalBuy - 1 : 1 - totalBuy / totalSell; // 空売りは売りポジションが分母
             _allProfitRatio += ratio;
             _allTerm += term;
             var profit = totalSell - totalBuy;
             _totalProfit += profit;
+            // 年度別のトータル資金
+            if (_totalProfitYear.ContainsKey(year) == true)
+            {
+                _totalProfitYear[year] += profit;
+                _totalProfitMonth[T(year, month - 1)] += profit;
+                _allTradesYear[year]++;
+                _allTradesMonth[T(year, month - 1)]++;
+                if (profit >= 0)
+                {
+                   _totalWinTradesYear[year]++;
+                   _totalWinTradesMonth[T(year, month - 1)]++;
+                   _totalWinMaxProfitYear[year] += profit;
+                   _totalWinMaxProfitMonth[T(year, month - 1)] += profit;
+                }
+                else
+                {
+                   _totalLoseMaxProfitYear[year] += profit;
+                   _totalLoseMaxProfitMonth[T(year, month - 1)] += profit;
+                }
+                if (totalSell < totalBuy) // 負け
+                {
+                    _totalMaxDrowDownYear[year] = Math.Min(_totalMaxDrowDownYear[year], ratio);
+                    if (_totalMaxBookDrowDownYear[year] > totalSell - totalBuy)
+                    {
+                         _totalMaxBookDrowDownYear[year] = totalSell - totalBuy;
+                         _maxBookDrowDawnDate[year] = date;
+                    }
+                    _totalMaxDrowDownMonth[T(year, month - 1)] = Math.Min(_totalMaxDrowDownMonth[T(year, month - 1)], ratio);
+                }
+                if (_totalMaxMarketDrowDownYear[year] > dailyprofit.Market)
+                {
+                    _totalMaxMarketDrowDownYear[year] = dailyprofit.Market;
+                    _maxMarketDrowDawnDate[year] = date;
+                }
+            }
+            else
+            {
+                _totalProfitYear.Add(year, profit);
+                for (int i = 0; i < 12; i++)
+                {
+                    _totalProfitMonth.Add(T(year, i), 0);
+                    _allTradesMonth.Add(T(year, i), 0);
+                    _totalWinTradesMonth.Add(T(year, i), 0);
+                    _totalMaxDrowDownMonth.Add(T(year, i), 0);
+                    _totalWinMaxProfitMonth.Add(T(year, i), 0);
+                    _totalLoseMaxProfitMonth.Add(T(year, i), 0);
+                }
+                _totalProfitMonth[T(year, month - 1)] = profit;
+                _allTradesYear.Add(year, 1);
+                _allTradesMonth[T(year, month - 1)] ++;
+                if (profit >= 0)
+                {
+                   _totalWinTradesYear.Add(year, 1);
+                   _totalWinTradesMonth[T(year, month - 1)] = 1;
+                   _totalWinMaxProfitYear.Add(year, profit);
+                   _totalWinMaxProfitMonth[T(year, month - 1)] = profit;
+                   _totalLoseMaxProfitYear.Add(year, 0);
+                }
+                else
+                {
+                   _totalWinTradesYear.Add(year, 0);
+                   _totalWinMaxProfitYear.Add(year, 0);
+                   _totalLoseMaxProfitYear.Add(year, profit);
+                   _totalLoseMaxProfitMonth[T(year, month - 1)] = profit;
+                }
+                if (totalSell < totalBuy) // 負け
+                {
+                    _totalMaxDrowDownYear.Add(year, ratio);
+                    _totalMaxDrowDownMonth[T(year, month - 1)] = ratio;
+                    _totalMaxBookDrowDownYear.Add(year, dailyprofit.Market);
+                    _maxBookDrowDawnDate[year] = date;
+                    _totalMaxMarketDrowDownYear.Add(year, dailyprofit.Market);
+                    _maxMarketDrowDawnDate[year] = date;
+
+                }
+                else
+                {
+                    _totalMaxDrowDownYear.Add(year, 0);
+                    _totalMaxBookDrowDownYear.Add(year, 0);
+                    _totalMaxMarketDrowDownYear.Add(year, 0);
+                    _maxBookDrowDawnDate[year] = date;
+                    _maxMarketDrowDawnDate[year] = date;
+                }
+            }
             if (totalSell > totalBuy) // 勝ち
             {
                 _winTrades++;
+                if (_consecutiveWin >= 0)
+                {
+                     _consecutiveWin++;
+                }
+                else
+                {
+                     _consecutiveWin = 1;
+                }
+                _maxwinCount = Math.Max(_maxwinCount, _consecutiveWin);
                 _winProfitRatio += ratio;
                 _winMaxProfitRatio = Math.Max(_winMaxProfitRatio, ratio);
                 _winMaxProfit = Math.Max(_winMaxProfit, profit);
@@ -217,6 +382,15 @@
             }
             else // 負け
             {
+                if (0 > _consecutiveWin)
+                {
+                     _consecutiveWin--;
+                }
+                else
+                {
+                     _consecutiveWin = -1;
+                }
+                _maxloseCount = Math.Max(_maxloseCount, -1 * _consecutiveWin);
                 _loseMaxLossRatio = Math.Min(_loseMaxLossRatio, ratio);
                 _loseMaxLoss = Math.Min(_loseMaxLoss, profit);
             }
@@ -314,6 +488,81 @@
                 _winTotalProfit / -loseTotalLoss,
                 _bookMaxDrowDown, _marketMaxDrowDown,
                 _runningTrades));
+            // Dictionaryの内容をコピーして、List<KeyValuePair<int, float>>に変換
+            List<KeyValuePair<int, float>> list = new List<KeyValuePair<int, float>>(_allTradesYear);
+            list.Sort((a, b) => b.Key - a.Key);  //降順
+            var j = 0;
+            var _total = 0;
+            var _ave = 5; // 直近○年の平均年利を求める
+            foreach (KeyValuePair<int, float> pair in list)
+            {
+                j += 1;
+                _total += (int)_totalProfitYear[pair.Key];
+                if (j >= _ave)
+                {
+                     break;
+                }
+            }
+            appendText(string.Format(
+                           "----------------------------------------\n" +
+                           "平均年利\t\t{0:p}\n" +
+                           "平均年利(直近{1:d}年)\t{2:p}\n" +
+                           "最大連勝\t\t{3:d}回\n" +
+                           "最大連敗\t\t{4:d}回\n",
+                           (_totalProfit / _allTradesYear.Count) / _budget,
+                           _ave,
+                           (_total / _ave) / _budget,
+                           _maxwinCount,
+                           _maxloseCount
+                           ));
+            appendText(string.Format(
+                           "----------------------------------------\n" +
+                           "[年度別レポート]\n"));
+            appendText(string.Format("年度\t取引回数\t運用損益\t年利\t勝率\tPF\t最大DD\n"));
+            foreach (KeyValuePair<int, float> pair in list)
+            {
+                appendText(string.Format(
+                    "{0}年\t{1,5}回\t\t{2:c}円\t{3:p}\t{4:p}\t{5,5:n}倍\t{6,6:p}\n",
+                        pair.Key, pair.Value, _totalProfitYear[pair.Key],
+                        _totalProfitYear[pair.Key] / _budget,
+                        _totalWinTradesYear[pair.Key] / pair.Value,
+                        Math.Abs(_totalWinMaxProfitYear[pair.Key] / _totalLoseMaxProfitYear[pair.Key]),
+                        _totalMaxDrowDownYear[pair.Key]
+                    ));
+            }
+            appendText(string.Format(
+                           "----------------------------------------\n" +
+                           "[年度別ドローダウンレポート]\n"));
+            appendText(string.Format("年度\t\t最大DD(簿価)\t\t\t最大DD(時価)\n"));
+            foreach (KeyValuePair<int, float> pair in list)
+            {
+                appendText(string.Format(
+                    "{0}年\t\t{1:c}({2})\t\t{3:c}({4})\n",
+                        pair.Key,
+                        (_totalMaxBookDrowDownYear[pair.Key]),
+                        _maxBookDrowDawnDate[pair.Key].ToString("yyyy/MM/dd"),
+                        (_totalMaxMarketDrowDownYear[pair.Key]),
+                        _maxMarketDrowDawnDate[pair.Key].ToString("yyyy/MM/dd")
+                    ));
+            }
+            appendText(string.Format(
+                           "----------------------------------------\n" +
+                           "[月別レポート]\n"));
+            foreach (KeyValuePair<int, float> pair in list)
+            {
+                appendText(string.Format("[{0}年]\n", pair.Key));
+                appendText(string.Format("月度\t取引回数\t運用損益\t勝率\tPF\t最大DD\n"));
+                for (int i = 12 - 1; i >= 0; i--)
+                {
+                    appendText(string.Format(
+                                   "{0,2}月\t{1}回\t\t{2:c}円\t{3,6:p}\t{4,5:n}倍\t{5,6:p}\n",
+                                   i + 1, _allTradesMonth[T(pair.Key, i)], _totalProfitMonth[T(pair.Key, i)],
+                                   _totalWinTradesMonth[T(pair.Key, i)] / _allTradesMonth[T(pair.Key, i)],
+                                   Math.Abs(_totalWinMaxProfitMonth[T(pair.Key, i)] / _totalLoseMaxProfitMonth[T(pair.Key, i)]),
+                                   _totalMaxDrowDownMonth[T(pair.Key, i)]
+                                   ));
+                }
+            }
         }
     }
-}
\ No newline at end of file
+}
